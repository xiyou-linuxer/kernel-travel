在从内核态转化到用户态时，对每一个进程进行检查，是否有信号已到达。

```c
typedef struct {
    unsigned long sig[2];
} sigset_t;
```

pcb: struct sigpending pending, sigset_t blocked
```c
struct sigpending {
    sigset_t signal;
};
```
blocked 存放进程所屏蔽的信号


第一步信号产生
更新进程的pending，唤醒相应进程。
什么情况唤醒？

`specific_sendsig` 更新某个特定的进程的挂起信号集
如果是某些信号需要忽略




第二步处理产生的信号
在返回用户态前检查信号 `check_signals`
处理未被屏蔽的信号

```c
struct k_sigaction {
    void (*sa_handler)(int);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
};
```


```c
typedef struct {
    struct lock lock;
    struct k_sigaction action[SIGMAX];
} sighand_t;
```

如果是终止信号，调用`sys_exit`退出；
否则保存当前上下文，执行信号处理函数。



