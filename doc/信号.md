在从内核态转化到用户态时，对每一个进程进行检查，是否有信号已到达。

```c
typedef struct {
    unsigned long sig[2];
} sigset_t;
```

pcb: struct sigpending pending, sigset_t blocked
```c
struct sigpending {
    sigset_t signal;
};
```
blocked 存放进程所屏蔽的信号


第一步信号产生
`specific_sendsig` 更新某个特定的进程的挂起信号集
如果是某些信号需要忽略
更新进程的pending
如果SIGKILL，唤醒相应进程。 



第二步处理产生的信号
在返回用户态前检查信号 `check_signals`
处理未被屏蔽的信号

```c
struct k_sigaction {
    void (*sa_handler)(int);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
};
```


```c
typedef struct {
    struct lock lock;
    struct k_sigaction action[SIGMAX];
} sighand_t;
```

如果是终止信号，调用`sys_exit`退出；
否则保存当前上下文，执行信号处理函数。

根据ka的信息，更新屏蔽的信号
`set_frame` 建立用户信号堆栈
修改regs，为待会儿进入用户态信号处理程序做准备：
era指向信号处理程序;
sp指向建立的用户信号堆栈;
a0填入信号参数
ra保存返回地址为`sigreturn_code`

`sigreturn_code`
调用系统调用`sys_return`
恢复原来的上下文和屏蔽信号集


