# 任务创建与切换

每一个任务都有一个控制块，记载了任务的各种信息。

```c
struct task_struct {
	uint64_t *self_kstack;
	thread_func *function;
	void *func_arg;
	struct thread_struct thread;
	struct tms time_record;
	struct start_tms start_times;
	pid_t ppid;
	pid_t pid;
	enum task_status status;
	int16_t exit_status;
	char name[TASK_NAME_LEN];
	uint8_t priority;
	uint8_t ticks;
	uint32_t elapsed_ticks;
	struct virt_addr usrprog_vaddr;
	struct list_elem general_tag;
	int fd_table[MAX_FILES_OPEN_PER_PROC]; 
	char cwd[MAX_NAME_LEN];					
	struct Dirent* cwd_dirent;				
	struct list_elem all_list_tag;
	uint64_t pgdir;
	u32 asid;
	struct mm_struct *mm;
	uint32_t stack_magic;
};
```

本OS把线程作为调度的基本单位，进程与线程的主要区别在进程有自己的虚拟空间。线程的pgdir为零，进程的pgdir指向进程的PGD。



## 任务创建与销毁

### 创建

`thread_start` 创造线程

1.初始化任务控制块。

2.将任务控制块加入到`thread_ready_list` 和 `thread_all_list` 中。



`process_execute` 创造进程

1.按创造线程的流程走。

2.在线程的基础上创建页表并初始化管理虚拟内存的位图。



`sys_fork` 系统调用，复制父进程

跟 `process_execute` 差不多，但是复制自父进程，包括任务控制块以及内存中的内容。



##### 设置页表，填写物理内存

CPU 复位结束后将进入直接地址翻译模式。该模式CSR.CRMD 中的 DA 域为 1 且 PG 域为 0。直接映射配置窗口共设置有四个,前两个窗口可同时用于取指和 load/store 操作,后两个窗口仅用于load/store 操作。

经过`head.S`的设置，到`start_kernel`时已经是开了窗口的状态，一致可缓存的内存空间。0x9000000000000000 ~ 0x9000FFFFFFFFFFFF 被映射到物理地址空间 0x0 ~ 0xFFFFFFFFFFFF 上。

用户进程的pcb与页表保存在内核空间（直接窗口映射），不需要建立页表映射关系。而给用户进程的代码块和栈分配的物理页需与虚拟地址建立映射关系。



### 销毁

进程结束调用 `sys_exit` ， 回收分配的页框。此时该进程变成僵尸进程，只有任务控制块存在。

父进程调用wait()后会提取子进程的退出状态，并回收任务控制块。





### 任务切换

切换时机：任务时间片用完，即控制块中的ticks为零。或者其他需要被调度的情况。

任务控制块中有个 `thread_struct` ，保存着被切任务的上下文。

```c
struct thread_struct {
	/* Main processor registers. */
	unsigned long reg01, reg03, reg22; /* ra sp fp */
	unsigned long reg23, reg24, reg25, reg26; /* s0-s3 */
	unsigned long reg27, reg28, reg29, reg30, reg31; /* s4-s8 */

	/* __schedule() return address / call frame address */
	unsigned long sched_ra;
	unsigned long sched_cfa;

	/* CSR registers */
	unsigned long csr_prmd;
	unsigned long csr_crmd;
	unsigned long csr_euen;
	unsigned long csr_ecfg;
	unsigned long csr_badvaddr; /* Last user fault */

	/* Scratch registers */
	unsigned long scr0;
	unsigned long scr1;
	unsigned long scr2;
	unsigned long scr3;

	/* Eflags register */
	unsigned long eflags;
};
```

在schedule()的时候激活用户进程的pdir（一级页表）。

`switch_to` 保存当前任务上下文，并根据下一个任务的控制块中的`thread_struct`切换到下一个任务。







